<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ansible + Terraform Project Blog</title>
  <style>
    /* Reset */
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Segoe UI', Tahoma, sans-serif;
      background: #f9fafc;
      color: #333;
      line-height: 1.6;
    }

    header {
      background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
      color: #fff;
      text-align: center;
      padding: 2rem 1rem;
    }
    header h1 { font-size: 2rem; margin-bottom: .5rem; }
    header p { font-size: 1.1rem; opacity: 0.9; }

    main {
      display: flex;
      max-width: 1200px;
      margin: 2rem auto;
      padding: 0 1rem;
      gap: 2rem;
    }

    /* Sidebar */
    aside {
      flex: 1;
      max-width: 250px;
      position: sticky;
      top: 20px;
      height: fit-content;
      background: #fff;
      border-radius: 12px;
      padding: 1rem;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
    }
    aside h3 {
      margin-bottom: 1rem;
      color: #0f3460;
    }
    aside ul {
      list-style: none;
      font-size: 0.95rem;
    }
    aside ul li { margin-bottom: 0.5rem; }
    aside ul li a {
      text-decoration: none;
      color: #444;
      transition: color 0.2s;
    }
    aside ul li a:hover { color: #0f3460; }

    .screenshot { margin: 1.5rem 0; text-align: center; }
    .screenshot img { max-width: 100%; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.15); }

    /* Content */
    article {
      flex: 3;
      background: #fff;
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
    }

    article h2 {
      margin-top: 2rem;
      margin-bottom: 1rem;
      color: #0f3460;
      font-size: 1.5rem;
    }
    article h3 { margin-top: 1.5rem; margin-bottom: .5rem; color: #16213e; }
    article p, article li, article pre { margin-bottom: 1rem; }

    ul, ol { margin-left: 1.2rem; }

    pre {
      background: #1e1e1e;
      color: #dcdcdc;
      padding: 1rem;
      border-radius: 8px;
      overflow-x: auto;
      font-size: 0.9rem;
    }
    code {
      font-family: monospace;
    }

    details {
      margin: 1rem 0;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 0.8rem;
      background: #fafafa;
    }

    summary {
      font-weight: bold;
      cursor: pointer;
      color: #0f3460;
    }

    footer {
      margin-top: 3rem;
      padding: 1rem;
      text-align: center;
      background: #0f3460;
      color: #fff;
      border-top-left-radius: 12px;
      border-top-right-radius: 12px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Ansible Practice with Terraform-Provisioned EC2 Instances</h1>
    <p>End-to-end infrastructure automation using Terraform + Ansible on AWS</p>
  </header>

  <main>
    <!-- Sidebar / TOC -->
    <aside>
      <h3>üìë Contents</h3>
      <ul>
        <li><a href="#infra">Infrastructure Setup</a></li>
        <li><a href="#master">Configuring Ansible Master</a></li>
        <li><a href="#inventory">Inventory Setup</a></li>
        <li><a href="#connection">Testing Connection</a></li>
        <li><a href="#playbooks">Playbooks</a></li>
        <li><a href="#mini">Mini Project</a></li>
        <li><a href="#skills">Skills Practiced</a></li>
        <li><a href="#tools">Tools Used</a></li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </aside>

    <!-- Content -->
    <article>
      <h2 id="infra">1Ô∏è‚É£ Infrastructure Setup with Terraform</h2>
      <h3>Created 4 EC2 instances: 1 Master + 3 Managed Nodes.</h3>
      <p>
        I started this project by building the infrastructure using Terraform. 
        The setup included 4 EC2 instances: 1 dedicated as the Ansible Master and 3 acting as managed nodes. 
        Using Terraform gave me full control over the provisioning process, from defining the instance type and AMI to configuring volumes and tagging resources. 
        This approach made the environment reproducible and consistent, which is a huge benefit for real-world automation projects.
      </p>
      <pre style="max-height: 400px; overflow: auto;"><code>
        # ===== Key Pairs =====

resource aws_key_pair master_key {
    key_name = "${var.master}-key"
    public_key = file("ansible-master-key.pub")

    tags = {
        Environment = var.env
    }
}

resource aws_key_pair server_key {
    key_name = "${var.server}-key"
    public_key = file("ansible-server-key.pub")

    tags = {
        Environment = var.env
    }
}

# ===== Default VPC Data Source =====

resource aws_default_vpc default {

}

# ===== Security Group for Servers =====

resource aws_security_group instance_sg {
    name = var.sg_name
    description = "This will add a TF generated SSH and HTTP access"
    vpc_id = aws_default_vpc.default.id # interpolation

    # inbound rules
    ingress {
        from_port = 22
        to_port = 22
        protocol = "tcp"
        cidr_blocks = ["0.0.0.0/0"] # source IPs
        description = "SSH access"
    }
    ingress {
        from_port = 80
        to_port = 80
        protocol = "tcp"
        cidr_blocks = ["0.0.0.0/0"]
        description = "HTTP access"
    }

    # outbound rules
    egress {
        from_port = 0
        to_port = 0
        protocol = "-1" # all protocols
        cidr_blocks = ["0.0.0.0/0"]
        description = "all access open"
    }

    tags = {
        Name = "ansible-sg"
    }
}

# ===== Master Instance =====

resource "aws_instance" "ansible-master" {
    
    depends_on = [ aws_security_group.instance_sg, aws_key_pair.master_key ]
    
    key_name = aws_key_pair.master_key.key_name
    security_groups = [aws_security_group.instance_sg.name]
    instance_type = var.instance_type
    ami = var.ami_id

    root_block_device {
        volume_size =  16
        volume_type = "gp3"
    }
    tags = {
        Name = var.master
        Environment = var.env
    }
}

# ===== 3 Server Instances =====

resource "aws_instance" "ansible-server" {
    count = 3
    
    depends_on = [ aws_security_group.instance_sg, aws_key_pair.server_key ]
    
    key_name = aws_key_pair.server_key.key_name
    security_groups = [aws_security_group.instance_sg.name]
    instance_type = var.instance_type
    ami = var.ami_id

    root_block_device {
        volume_size =  8
        volume_type = "gp3"
    }
    tags = {
        Name = "${var.server}-${count.index + 1}"
        Environment = var.env
    }
}</code></pre>

      <h2 id="master">2Ô∏è‚É£ Configuring Ansible Master</h2>
      <p>
        Once the infrastructure was ready, I set up the Ansible Master node. 
        The process included installing Ansible on the master and transferring the private key from my local system to the master so it could connect securely with all managed nodes. 
        This setup formed the foundation for running Ansible commands and playbooks across the environment.
        In this case the key-pair was same for all the instances, so I just required to copy a single private key to master node.
      </p>
      <pre><code>sudo apt update && sudo apt install ansible -y
scp -i my-key.pem my-key.pem ubuntu@&lt;master-ip&gt;:/home/ubuntu/</code></pre>

      <h2 id="inventory">3Ô∏è‚É£ Inventory File Setup</h2>
      <p>
        The next step was to configure the inventory file located at <code>/etc/ansible/hosts</code>. 
        This file defines all the managed nodes along with their Public IPs and the required authentication key details. 
        By maintaining this inventory, I could group servers logically and target specific ones when running playbooks or ad-hoc commands.
      </p>
      <pre><code>
[servers]
server1 ansible_host=10.0.0.11 ansible_user=ubuntu ansible_ssh_private_key_file=~/my-key.pem
server2 ansible_host=10.0.0.12 ansible_user=ubuntu ansible_ssh_private_key_file=~/my-key.pem
server3 ansible_host=10.0.0.13 ansible_user=ubuntu ansible_ssh_private_key_file=~/my-key.pem
</code></pre>

      <h2 id="connection">4Ô∏è‚É£ Testing Ansible Connection</h2>
      <p>
        Before moving forward, I verified the connectivity between the master and all managed nodes using Ansible‚Äôs <code>ping</code> module. 
        Successfully receiving responses confirmed that the configuration was correct and the master could communicate with the servers without issues.
      </p>
      <pre><code>ansible all -m ping
ansible servers -m ping
ansible servers -a "uptime"</code></pre>

      <h2 id="playbooks">5Ô∏è‚É£ Playbooks</h2>
      <p>
    As part of system maintenance, I used Ansible modules to update package repositories and ensure all servers were running with the latest packages. 
    Running this task through Ansible not only saved time but also guaranteed consistency across all nodes, avoiding the manual process of updating each server one by one.
  </p>
      <h3>Update Packages</h3>
      <pre><code>ansible all -m apt -a "update_cache=yes" --become</code></pre>

      <h3>Show Date & Uptime</h3>
      <p>
        My first playbook was a simple one that displayed the current date and uptime on all servers. 
        While this may look basic, it gave me hands-on experience with how playbooks are structured and how tasks are executed across multiple servers simultaneously. 
        It was the first step in automating repetitive checks.
      </p>
      <pre><code>- hosts: servers
  tasks:
    - name: Show date
      command: date
    - name: Show uptime
      command: uptime</code></pre>

      <h3>Install Nginx</h3>
      <p>
        Next, I wrote a playbook to install and configure Nginx on all servers. 
        The playbook ensured that Nginx was installed, started, and enabled to run on boot. 
        This step highlighted the power of configuration management‚Äîbeing able to standardize software installation and configuration across multiple systems in one go.
      </p>
      <pre><code>-
name: Install Nginx and start it
hosts: servers
become: yes
tasks:
    - name: Install Nginx
    apt:
        name: nginx
        state: latest
    - name: Start Nginx
    service:
        name: nginx
        state: started
        enabled: yes</code></pre>

        <h2 id="connection">6Ô∏è‚É£ Using Groups in Inventory</h2>
        <p>
            To make the inventory more flexible, I introduced server groups. 
            For example, I created a ‚Äúweb‚Äù group to target only the server intended for hosting a website. 
            This allowed me to run commands or playbooks against specific sets of servers, which is exactly how environments are structured in professional setups like dev, test, and prod.
          </p>
      <pre><code>[web]
server1 ansible_host=10.0.0.11 ansible_user=ubuntu ansible_ssh_private_key_file=~/my-key.pem
server2 ansible_host=10.0.0.12 ansible_user=ubuntu ansible_ssh_private_key_file=~/my-key.pem</code></pre>

      <h2 id="mini">7Ô∏è‚É£ Mini Project ‚Äì Deploy Custom Web Page</h2>
      <p>
        To bring all the concepts together, I created a small project where Ansible automated the setup of a custom website. 
        The playbook handled Nginx installation, service management, and deployment of a custom <code>index.html</code> file to the server‚Äôs web root. 
        After running the playbook, I could access my custom web page via the public IP of the target server. 
        This mini project was a practical demonstration of how Ansible can be used for real-world automation‚Äîfrom provisioning to application deployment.
      </p>
      <p>
        The result was a fully automated workflow where infrastructure was created with Terraform and configured with Ansible, ending with a deployed and running web application.
      </p>
      <pre><code>-
name: Install nginx and server static website
hosts: web
become: yes
tasks:
    - name: Install Nginx
    apt:
        name: nginx
        state: latest
      
    - name: Start Nginx
    service:
        name: nginx
        state: started
        enabled: yes
      
    - name: Deploy web page
    copy:
        src: index.html
        dest: /var/www/html/</code></pre>

      <p>‚úÖ Result: Custom webpage deployed successfully on web group server.</p>

      <div class="screenshot">
        <p>Deployed Webpage Screenshot</p>
        <img src="images/Project2.png" alt="Jenkins Pipeline">
      </div>

      <section id="skills">
        <h2>üßë‚Äçüíª Skills Practiced</h2>
        <ul>
          <li>Provisioning infrastructure with <strong>Terraform</strong></li>
          <li>Running Ansible <strong>ad-hoc commands</strong></li>
          <li>Managing inventory with <strong>groups</strong></li>
          <li>Creating and executing <strong>playbooks</strong></li>
          <li>Automating <strong>web application deployment</strong></li>
        </ul>
      </section>
      
      <section id="tools">
        <h2>üõ† Tools Used</h2>
        <ul>
          <li><strong>Terraform</strong> ‚Äì for infrastructure provisioning</li>
          <li><strong>Ansible</strong> ‚Äì for configuration management & automation</li>
          <li><strong>AWS EC2</strong> ‚Äì as the cloud platform for servers</li>
        </ul>
      </section>
      
      <section id="summary">
        <h2>üìñ Summary</h2>
        <p>
          This project demonstrates end-to-end <strong>infrastructure automation</strong> 
          using Terraform and Ansible. I provisioned AWS EC2 instances with Terraform, 
          configured secure SSH access, and used Ansible for server automation. 
          The project covered ad-hoc commands, inventory grouping, and writing 
          playbooks for tasks like package installation, service management, and 
          automated deployment of a custom website. 
        </p>
        <p>
          By combining <strong>Terraform + Ansible</strong>, I built a reproducible, 
          scalable, and automated workflow that closely mirrors real-world DevOps practices.
        </p>
      </section>
      
    </article>
  </main>

  <footer>
    &copy; 2025 CoolBrand ‚Äì Terraform + Ansible Project
  </footer>
</body>
</html>
